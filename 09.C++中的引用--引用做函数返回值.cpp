//引用可以做函数的返回值存在
//注意：不要返回局部变量引用
//用法：函数调用作为左值
#include<iostream>
using namespace std;

//不要返回局部变量引用
int& test0901()
{
	int a = 10; //局部变量存放在内存四区中的栈区
	return a;
}

//返回静态变量引用，函数的调用可以作为左值
int& test0902()
{
	static int a = 20;//静态变量，存放在全局区，全局区上的数据在程序结束后由系统释放
	return a;
}

int main09()
{
	int& ref = test0901();

	// VS2022 和的编译器版本和位数不一样，此处结果也不一样，这里的注释按照视频版本x86 VS2017
	cout << "ref = " << ref << endl;//第一次结果正确，是因为编译器做了保留
	cout << "ref = " << ref << endl;// 第二次结果错误，因为a的内存已经释放

	int &ref2 = test0902();  
	cout << "ref2 = " << ref2 << endl;
	cout << "ref2 = " << ref2 << endl;

	test0902() = 1000;   //test02( )即为函数的调用，在等号的左边叫做左值
	//如果函数的返回值是一个引用，这个函数的调用可以左值

	cout << "ref2 = " << ref2 << endl;
	cout << "ref2 = " << ref2 << endl;

	system("pause");
	return 0;
}
/*
在给定的C++代码中，`test02()` 和 `ref2` 都是引用，且都引用了静态局部变量 `a`。
1.	`test02()` 是一个函数，返回类型是 `int&`，表示它返回一个整数类型的引用。

2.	在 `test02()` 函数内部，有一个静态局部变量 `a`，它的初始值为 20。
	这意味着 `a` 在程序执行期间只会初始化一次，并且在函数调用之间保持其值。

3.	在 `main()` 函数中，`int& ref2 = test02();` 这一行代码创建了一个引用 `ref2`，
	它被初始化为调用 `test02()` 后返回的引用。因为 `test02()` 返回的是 `a` 的引用，
	所以 `ref2` 实际上也引用了静态局部变量 `a`。

4.	然后，`test02() = 1000;` 这一行代码将静态局部变量 `a` 的值设置为 1000。
	由于 `ref2` 引用了 `a`，所以 `ref2` 引用的值也会被修改为 1000。

综上所述，`test02()` 和 `ref2` 都是静态局部变量 `a` 的引用，它们引用了同一个内存位置，因此对其中任何一个进行修改都会影响到另一个。

*/