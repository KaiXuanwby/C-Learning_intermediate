//C++中拷贝构造函数调用时机通常有三种情况
/*
使用一个已经创建完毕的对象来初始化一个新对象
值传递的方式给函数参数传值
以值方式返回局部对象
*/
#include<iostream>
using namespace std;

class Person25
{
public:
	Person25()
	{
		cout << "Person的默认构造函数调用" << endl;
	}
	Person25(int age)
	{
		cout << "Person的有参构造函数调用" << endl;
		per_age = age;
	}
	Person25(const Person25 &p)
	{
		cout << "Person的拷贝构造函数调用" << endl;
		per_age = p.per_age;
	}

	~Person25()
	{
		cout << "Person的析构函数调用" << endl;
	}
	int per_age;
};

//1、使用一个已经创建完毕的对象来初始化一个新对象
void test2501()
{
	Person25 p1(20);
	Person25 p2(p1);

	cout << "P2的年龄为：" << p2.per_age << endl;
}

//2、值传递的方式给函数参数传值  ：值传递的特点，如果是地址或者引用不会产生拷贝构造函数
void doWork2501(Person25 p)  //值传递相当于Person25 p = p 拷贝构造函数的隐式写法
{                        //值传递相当于复制一份，复制就会执行拷贝构造函数

}
void test2502()
{
	Person25 p;  //默认构造函数
	doWork2501(p);   //拷贝构造函数
}

//3、以值方式返回局部对象
Person25 doWork2()
{
	Person25 p1;  //默认构造函数
	cout << (int*)&p1 << endl;
	return p1;    //如果没有返回值优化，就是拷贝构造函数，p1为局部变量，调用完后销毁，返回值返回的p1是复制的
	//return Person25(p1);   //强调返回值应该是拷贝构造函数
}
void test2503()
{
	Person25 p = doWork2();
	cout << (int*)&p << endl;
}

int main25()
{
	//test2501();
	//test2502();
	test2503();
	system("pause");
	return 0;
}

/*
拷贝构造函数在以下几种情况下会被自动调用：

1. **使用一个对象初始化另一个对象：** 当你用一个已存在的对象初始化一个新对象时，拷贝构造函数会被调用。这可以发生在以下情况下：
   ```cpp
   MyClass obj1;  // 创建一个对象
   MyClass obj2(obj1);  // 使用拷贝构造函数初始化新对象
   ```

2. **将一个对象作为函数参数传递给函数：** 当你将一个对象作为参数传递给函数时，函数的参数会通过拷贝构造函数进行初始化。这里包括传值方式的参数传递和返回对象时的情况。
   ```cpp
   void myFunction(MyClass obj);  // 传值方式传递对象，拷贝构造函数被调用
   MyClass myFunction() {
	   MyClass obj;
	   return obj;  // 返回对象，拷贝构造函数被调用
   }
   ```

3. **从函数返回一个对象：** 如果你的函数返回一个对象，那么拷贝构造函数会被调用以创建返回值的副本。
   ```cpp
   MyClass myFunction() {
	   MyClass obj;
	   return obj;  // 返回对象，拷贝构造函数被调用
   }
   ```

4. **使用对象初始化容器元素：** 当你使用对象来初始化容器元素，或者将对象插入容器中，拷贝构造函数也会被调用。
   ```cpp
   std::vector<MyClass> myVector;
   MyClass obj;
   myVector.push_back(obj);  // 插入对象到容器中，拷贝构造函数被调用
   ```

请注意，有时候编译器可能会进行优化，避免不必要的拷贝构造函数调用，这就是所谓的“拷贝构造函数优化”。例如，C++11引入了移动语义，可以避免在某些情况下的不必要的拷贝，提高了性能。

如果你希望控制拷贝构造函数的行为，你可以手动定义拷贝构造函数并实现你自己的逻辑。默认情况下，编译器会生成一个默认的拷贝构造函数，但在某些情况下，你可能需要自定义它来确保正确的行为。
*/
/*
C++的拷贝构造函数优化主要是通过引入移动语义来实现的。移动语义允许在某些情况下，将资源（如动态分配的内存）从一个对象转移到另一个对象，而无需执行昂贵的拷贝操作。这可以显著提高程序的性能，尤其是在涉及大量数据的情况下。

在传统的拷贝构造函数中，当一个对象被复制到另一个对象时，需要将所有成员逐个复制，包括动态分配的资源，这可能会导致不必要的性能开销。而移动构造函数则允许在某些情况下，将资源的所有权从一个对象“移动”到另一个对象，而无需复制资源本身。

移动构造函数的主要原理是利用了右值引用（rvalue references）和特殊的移动语义操作符（`std::move`），以及移动构造函数的自定义实现。

1. **右值引用（rvalue references）：** C++11引入了右值引用的概念，通过使用双 && 符号来表示。右值引用允许我们标识出临时对象、即将销毁的对象以及可以“窃取”资源的对象。这使得我们可以在移动语义中区分“可移动”资源和“不可移动”资源。

2. **`std::move`：** `std::move` 是一个用于将对象转换为右值引用的函数模板。它通常用于移动语义中，将一个对象标记为“可移动”，从而允许在移动构造函数中将资源的所有权转移。

3. **移动构造函数：** 移动构造函数是一个特殊的构造函数，用于实现移动语义。它允许从一个对象“窃取”资源，然后将所有权转移到另一个对象，而无需复制资源的内容。

当进行对象的拷贝或赋值操作时，编译器会根据上述原则自动选择调用拷贝构造函数或移动构造函数，以实现最优的性能。这种优化在涉及大量数据、动态内存分配或资源管理的情况下特别有效。

然而，需要注意的是，如果你手动实现了拷贝构造函数和移动构造函数，确保你正确地处理资源的所有权转移和复制，以避免悬空指针、内存泄漏等问题。
*/
/*
返回值优化原则：对于临时对象（也就是右值对象）编译器不会在内存中创建它，当把它赋值给一个左值对象时才会创建这个对象。
所以新编译器下，会发现输出的两个地址值是一样的
这个对象实际上被创建在了main函数的栈帧上，并没有额外创建一个新对象
*/
/*
1、现在的编译器优化过了，return的对象不会在函数结束后被析构，而是会用类似隐式转换的形式把地址传递给新的对象
3、之所以说是“类似隐式转换的形式”是因为，真正的隐式转换是会创建一个有新地址的新对象的，这个只是老对象改名了。大家可以多套几个娃试试
*/